import Foundation

/// Deterministic workflow signature extraction (no model calls).
struct WorkflowSignatureExtractor {
    private let minTextLength = 30

    private let exclusionPhrases = [
        "<local-command-stdout>",
        "<local-command-stderr>",
        "local-command-stdout",
        "local-command-stderr",
        "caveat: the messages below were generated by the user while running local commands",
        "<command-name>/clear",
        "this session is being continued"
    ]

    /// Phrases that indicate context priming - must appear at START of first user message
    private let primingPhrases = [
        "warmup",
        "please familiarize yourself",
        "familiarize yourself with the project",
        "please read the following guide",
        "read the following guide",
        "before we begin",
        "repository guidelines",
        "project structure",
        "review the docs",
        "review the documentation"
    ]

    private let genericPrefixes = [
        "what is",
        "who is",
        "how to",
        "how do i",
        "can i"
    ]

    private let actionPatterns: [(String, [String])] = [
        ("summarize", ["summarize", "summary", "tl;dr", "key points", "takeaways"]),
        ("translate", ["translate", "translation"]),
        ("research", ["research", "market research", "look up", "find info", "collect sources"]),
        ("write", ["write", "draft", "compose", "create", "generate"]),
        ("review", ["review", "critique", "feedback", "improve", "rewrite"]),
        ("fix", ["fix", "correct", "resolve", "repair"]),
        ("debug", ["debug", "error", "exception", "traceback", "bug"]),
        ("plan", ["plan", "roadmap", "milestone", "timeline"]),
        ("design", ["design", "layout", "ui", "ux"]),
        ("analyze", ["analyze", "analyse", "assessment", "evaluate"]),
        ("extract", ["extract", "identify", "pull out"])
    ]

    private let artifactPatterns: [(String, [String])] = [
        ("notes", ["notes", "minutes"]),
        ("summary", ["summary", "tl;dr"]),
        ("report", ["report"]),
        ("proposal", ["proposal", "pitch"]),
        ("deck", ["deck", "slides", "ppt"]),
        ("plan", ["plan", "roadmap", "timeline"]),
        ("spec", ["spec", "requirements"]),
        ("prompt", ["prompt"]),
        ("landing_page", ["landing page"]),
        ("post", ["post", "tweet", "newsletter", "blog"]),
        ("timestamps", ["timestamp"])
    ]

    private let domainPatterns: [(String, [String])] = [
        ("sales", ["sales", "lead", "outreach", "icp", "pipeline", "crm"]),
        ("marketing", ["marketing", "seo", "campaign"]),
        ("product", ["product", "feature", "spec"]),
        ("engineering", ["code", "debug", "api", "backend", "frontend"]),
        ("research", ["research", "market", "analysis", "insights"]),
        ("content", ["write", "draft", "post", "blog", "newsletter", "copy"]),
        ("translation", ["translate", "translation"]),
        ("meeting", ["workshop", "office hours", "meeting", "agenda"]),
        ("video", ["video", "youtube", "podcast"])
    ]

    func extractSignature(
        conversation: Conversation,
        messages: [Message]
    ) -> WorkflowSignatureCandidate? {
        if ConversationContentFilter.isMeta(conversation: conversation, messages: messages) {
            return nil
        }

        let firstUserMessage = messages.first(where: { $0.isUserMessage })?.content

        let mergedText = [
            conversation.title,
            conversation.previewText,
            firstUserMessage
        ]
        .compactMap { $0?.trimmingCharacters(in: .whitespacesAndNewlines) }
        .filter { !$0.isEmpty }
        .joined(separator: " ")

        let normalized = mergedText.lowercased()
        if exclusionPhrases.contains(where: { normalized.contains($0) }) {
            return nil
        }

        // Check for context priming - only in first user message, at START of text
        if let firstMsg = firstUserMessage {
            let firstMsgNormalized = firstMsg.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
            // Require priming phrase at the START of the message (not anywhere in text)
            if primingPhrases.contains(where: { firstMsgNormalized.hasPrefix($0) }) {
                let snippet = WorkflowSignatureCandidate.trimSnippet(firstMsg)
                return WorkflowSignatureCandidate(
                    signature: "prime|context|setup",
                    action: "prime",
                    artifact: "context",
                    domains: ["setup"],
                    snippet: snippet,
                    version: 2,
                    source: "deterministic",
                    detectorVersion: "workflow-det-v2",
                    confidence: nil,
                    isPriming: true
                )
            }
        }

        guard mergedText.count >= minTextLength else { return nil }

        guard let firstUserMessage else { return nil }
        let firstNormalized = firstUserMessage.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
        let trimmed = firstNormalized.trimmingCharacters(in: .whitespacesAndNewlines)
        if genericPrefixes.contains(where: { trimmed.hasPrefix($0) }) {
            return nil
        }

        guard let action = match(in: firstNormalized, patterns: actionPatterns) else {
            return nil
        }
        let artifact = match(in: firstNormalized, patterns: artifactPatterns)
        let domains = matchedDomains(in: firstNormalized)

        guard let finalArtifact = artifact else {
            return nil
        }

        let refinedArtifact = WorkflowSignatureRefiner.refineArtifact(
            action: action,
            artifact: finalArtifact,
            domains: domains,
            context: mergedText
        ) ?? finalArtifact

        let domainString = domains.sorted().joined(separator: ",")
        let signature = "\(action)|\(refinedArtifact)|\(domainString)"
        let snippet = WorkflowSignatureCandidate.trimSnippet(firstUserMessage)

        return WorkflowSignatureCandidate(
            signature: signature,
            action: action,
            artifact: refinedArtifact,
            domains: domains,
            snippet: snippet,
            version: 2,
            source: "deterministic",
            detectorVersion: "workflow-det-v2",
            confidence: nil,
            isPriming: false
        )
    }

    private func match(in text: String, patterns: [(String, [String])]) -> String? {
        for (name, keywords) in patterns {
            if keywords.contains(where: { text.contains($0) }) {
                return name
            }
        }
        return nil
    }

    private func matchedDomains(in text: String) -> [String] {
        var results: [String] = []
        for (domain, keywords) in domainPatterns {
            if keywords.contains(where: { text.contains($0) }) {
                results.append(domain)
            }
        }
        return results
    }
}

struct WorkflowSignatureCandidate {
    let signature: String
    let action: String
    let artifact: String
    let domains: [String]
    let snippet: String
    let version: Int
    let source: String
    let detectorVersion: String
    let confidence: Double?
    let isPriming: Bool

    static func trimSnippet(_ text: String, maxLength: Int = 180) -> String {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmed.count <= maxLength {
            return trimmed
        }
        let endIndex = trimmed.index(trimmed.startIndex, offsetBy: maxLength)
        return String(trimmed[..<endIndex]) + "..."
    }
}
