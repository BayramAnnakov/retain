import Foundation

/// Gemini-backed workflow signature extraction for automation candidates.
struct GeminiWorkflowSignatureExtractor {
    private let client: GeminiClient

    private let exclusionPhrases = [
        "<local-command-stdout>",
        "<local-command-stderr>",
        "local-command-stdout",
        "local-command-stderr",
        "caveat: the messages below were generated by the user while running local commands",
        "<command-name>/clear",
        "this session is being continued"
    ]

    private let primingPhrases = [
        "warmup",
        "please familiarize yourself",
        "familiarize yourself with the project",
        "please read the following guide",
        "read the following guide",
        "before we begin",
        "context:",
        "background:",
        "repository guidelines",
        "project structure",
        "review the docs",
        "review the documentation"
    ]

    private let allowedActions = [
        "summarize",
        "translate",
        "research",
        "write",
        "review",
        "fix",
        "debug",
        "plan",
        "design",
        "analyze",
        "extract",
        "prime",
        "none"
    ]

    private let allowedArtifacts = [
        "notes",
        "summary",
        "report",
        "proposal",
        "deck",
        "plan",
        "spec",
        "prompt",
        "landing_page",
        "post",
        "timestamps",
        "context",
        "none"
    ]

    private let allowedDomains = [
        "sales",
        "marketing",
        "product",
        "engineering",
        "research",
        "content",
        "translation",
        "meeting",
        "video",
        "setup"
    ]

    init(apiKey: String, model: String) {
        let config = GeminiClient.Configuration(apiKey: apiKey, model: model)
        self.client = GeminiClient(configuration: config)
    }

    /// Initialize with a pre-configured client (for testing)
    init(client: GeminiClient) {
        self.client = client
    }

    func extractSignature(conversation: Conversation, messages: [Message]) async -> WorkflowSignatureCandidate? {
        let firstUserMessage = messages.first(where: { $0.isUserMessage })?.content
        let firstUserNormalized = firstUserMessage?.lowercased() ?? ""
        let mergedText = [
            conversation.title,
            conversation.previewText,
            firstUserMessage
        ]
        .compactMap { $0?.trimmingCharacters(in: .whitespacesAndNewlines) }
        .filter { !$0.isEmpty }
        .joined(separator: " ")

        let normalized = mergedText.lowercased()
        if exclusionPhrases.contains(where: { normalized.contains($0) }) {
            return nil
        }

        if primingPhrases.contains(where: { normalized.contains($0) }) {
            let snippetSource = firstUserMessage ?? conversation.previewText ?? conversation.title ?? ""
            let snippet = WorkflowSignatureCandidate.trimSnippet(snippetSource)
            return WorkflowSignatureCandidate(
                signature: "prime|context|setup",
                action: "prime",
                artifact: "context",
                domains: ["setup"],
                snippet: snippet,
                version: 2,
                source: "gemini",
                detectorVersion: "workflow-gemini-v1",
                confidence: nil,
                isPriming: true
            )
        }

        let prompt = buildPrompt(conversation: conversation, firstUserMessage: firstUserMessage)
        let schema = buildSchema()

        do {
            let text = try await client.generateStructuredContent(prompt: prompt, schema: schema)
            let payload = try JSONDecoder().decode(GeminiWorkflowSignatureResponse.self, from: Data(text.utf8))

            if payload.isPriming {
                let snippetSource = firstUserMessage ?? conversation.previewText ?? conversation.title ?? ""
                let snippet = WorkflowSignatureCandidate.trimSnippet(snippetSource)
                return WorkflowSignatureCandidate(
                    signature: "prime|context|setup",
                    action: "prime",
                    artifact: "context",
                    domains: ["setup"],
                    snippet: snippet,
                    version: 2,
                    source: "gemini",
                    detectorVersion: "workflow-gemini-v1",
                    confidence: nil,
                    isPriming: true
                )
            }

            guard payload.isAutomationCandidate else { return nil }
            guard payload.action != "none", payload.artifact != "none" else { return nil }

            let actionKeywords = actionKeywordMap[payload.action] ?? [payload.action.replacingOccurrences(of: "_", with: " ")]
            let artifactKeywords = artifactKeywordMap[payload.artifact] ?? [payload.artifact.replacingOccurrences(of: "_", with: " ")]
            guard containsKeyword(firstUserNormalized, keywords: actionKeywords),
                  containsKeyword(firstUserNormalized, keywords: artifactKeywords) else {
                return nil
            }

            let domains = payload.domains.filter { !($0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty) }
            let domainString = domains.sorted().joined(separator: ",")
            let signature = "\(payload.action)|\(payload.artifact)|\(domainString)"
            let snippetSource = firstUserMessage ?? conversation.previewText ?? conversation.title ?? ""
            let snippet = WorkflowSignatureCandidate.trimSnippet(snippetSource)

            return WorkflowSignatureCandidate(
                signature: signature,
                action: payload.action,
                artifact: payload.artifact,
                domains: domains,
                snippet: snippet,
                version: 2,
                source: "gemini",
                detectorVersion: "workflow-gemini-v1",
                confidence: nil,
                isPriming: false
            )
        } catch {
            return nil
        }
    }

    private func buildPrompt(conversation: Conversation, firstUserMessage: String?) -> String {
        let title = conversation.title ?? ""
        let preview = conversation.previewText ?? ""
        let firstMessage = firstUserMessage ?? ""

        return """
You extract reusable automation workflow candidates from user prompts.
Use only the provided content. If the text is a warmup/context-priming request, mark isPriming true.
Action and artifact must be explicitly present in the first user message.
If there is no automatable workflow, mark isAutomationCandidate false.

Return JSON with fields:
- action: one of \(allowedActions.joined(separator: ", "))
- artifact: one of \(allowedArtifacts.joined(separator: ", "))
- domains: array of strings from \(allowedDomains.joined(separator: ", "))
- isPriming: boolean
- isAutomationCandidate: boolean
- reason: short justification

Title: \(title)
Preview: \(preview)
First user message: \(firstMessage)
"""
    }

    private func buildSchema() -> [String: Any] {
        [
            "type": "object",
            "properties": [
                "action": [
                    "type": "string",
                    "enum": allowedActions
                ],
                "artifact": [
                    "type": "string",
                    "enum": allowedArtifacts
                ],
                "domains": [
                    "type": "array",
                    "items": [
                        "type": "string",
                        "enum": allowedDomains
                    ]
                ],
                "isPriming": ["type": "boolean"],
                "isAutomationCandidate": ["type": "boolean"],
                "reason": ["type": "string"]
            ],
            "required": [
                "action",
                "artifact",
                "domains",
                "isPriming",
                "isAutomationCandidate",
                "reason"
            ]
        ]
    }

    private func containsKeyword(_ text: String, keywords: [String]) -> Bool {
        keywords.contains { text.contains($0) }
    }
}

private struct GeminiWorkflowSignatureResponse: Decodable {
    let action: String
    let artifact: String
    let domains: [String]
    let isPriming: Bool
    let isAutomationCandidate: Bool
    let reason: String
}
    private let actionKeywordMap: [String: [String]] = [
        "summarize": ["summarize", "summary", "tl;dr", "takeaways", "key points"],
        "translate": ["translate", "translation"],
        "research": ["research", "look up", "find info", "sources"],
        "write": ["write", "draft", "compose", "create", "generate"],
        "review": ["review", "feedback", "critique", "rewrite"],
        "fix": ["fix", "correct", "resolve", "repair"],
        "debug": ["debug", "error", "exception", "traceback"],
        "plan": ["plan", "roadmap", "milestone", "timeline"],
        "design": ["design", "layout", "ui", "ux"],
        "analyze": ["analyze", "analyse", "assessment", "evaluate"],
        "extract": ["extract", "identify", "pull out"]
    ]

    private let artifactKeywordMap: [String: [String]] = [
        "notes": ["notes", "minutes"],
        "summary": ["summary", "tl;dr"],
        "report": ["report"],
        "proposal": ["proposal", "pitch"],
        "deck": ["deck", "slides", "ppt"],
        "plan": ["plan", "roadmap", "timeline"],
        "spec": ["spec", "requirements"],
        "prompt": ["prompt"],
        "landing_page": ["landing page"],
        "post": ["post", "tweet", "newsletter", "blog"],
        "timestamps": ["timestamp"],
        "context": ["context", "background", "primer"]
    ]
