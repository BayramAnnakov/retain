import Foundation

/// Exports approved learnings to CLAUDE.md format
final class CLAUDEMDExporter {
    // MARK: - Export Options

    struct ExportOptions {
        var includeHeader: Bool = true
        var includeTimestamps: Bool = false
        var includeConfidence: Bool = false
        var groupByCategory: Bool = true
        var projectPath: String? = nil
    }

    // MARK: - Export

    /// Export learnings to CLAUDE.md format
    func export(learnings: [Learning], options: ExportOptions = ExportOptions()) -> String {
        var output = ""

        // Header
        if options.includeHeader {
            output += generateHeader(options: options)
        }

        // Group learnings by category
        if options.groupByCategory {
            let grouped = groupLearningsByCategory(learnings)

            for (category, categoryLearnings) in grouped.sorted(by: { $0.key < $1.key }) {
                output += "\n## \(category)\n\n"

                for learning in categoryLearnings {
                    output += formatLearning(learning, options: options)
                }
            }
        } else {
            output += "\n## Learnings\n\n"
            for learning in learnings {
                output += formatLearning(learning, options: options)
            }
        }

        // Footer
        output += generateFooter(options: options)

        return output
    }

    /// Export to a file
    func exportToFile(learnings: [Learning], url: URL, options: ExportOptions = ExportOptions()) throws {
        let content = export(learnings: learnings, options: options)
        try content.write(to: url, atomically: true, encoding: .utf8)
    }

    /// Append learnings to existing CLAUDE.md
    func appendToExisting(learnings: [Learning], url: URL, options: ExportOptions = ExportOptions()) throws {
        var existingContent = ""

        if FileManager.default.fileExists(atPath: url.path) {
            existingContent = try String(contentsOf: url, encoding: .utf8)
        }

        // Find the learnings section or create one
        let newLearnings = formatNewLearnings(learnings, options: options)

        if existingContent.contains("# Retain Learnings") {
            // Append to existing section
            if let range = existingContent.range(of: "# Retain Learnings") {
                let insertPoint = existingContent.index(after: range.upperBound)
                existingContent.insert(contentsOf: "\n\n" + newLearnings, at: insertPoint)
            }
        } else {
            // Add new section at end
            existingContent += "\n\n---\n\n# Retain Learnings\n\n" + newLearnings
        }

        try existingContent.write(to: url, atomically: true, encoding: .utf8)
    }

    // MARK: - Formatting

    private func generateHeader(options: ExportOptions) -> String {
        var header = """
        # Retain Learnings

        > Auto-extracted learnings from AI conversations.
        > These preferences help AI assistants understand how you like to work.

        """

        if let projectPath = options.projectPath {
            header += "\n**Project**: `\(projectPath)`\n"
        }

        header += "\n---\n"

        return header
    }

    private func generateFooter(options: ExportOptions) -> String {
        let timestamp = ISO8601DateFormatter().string(from: Date())
        return """

        ---

        *Generated by Retain on \(timestamp)*
        """
    }

    private func formatLearning(_ learning: Learning, options: ExportOptions) -> String {
        var line = "- \(learning.extractedRule)"

        if options.includeConfidence {
            let confidence = Int(learning.confidence * 100)
            line += " _(confidence: \(confidence)%)_"
        }

        if options.includeTimestamps {
            let formatter = DateFormatter()
            formatter.dateStyle = .short
            line += " [\(formatter.string(from: learning.createdAt))]"
        }

        line += "\n"

        return line
    }

    private func formatNewLearnings(_ learnings: [Learning], options: ExportOptions) -> String {
        var output = ""
        for learning in learnings {
            output += formatLearning(learning, options: options)
        }
        return output
    }

    // MARK: - Categorization

    private func groupLearningsByCategory(_ learnings: [Learning]) -> [String: [Learning]] {
        var grouped: [String: [Learning]] = [:]

        for learning in learnings {
            let category = categorize(learning)

            if grouped[category] == nil {
                grouped[category] = []
            }
            grouped[category]?.append(learning)
        }

        return grouped
    }

    private func categorize(_ learning: Learning) -> String {
        let rule = learning.extractedRule.lowercased()

        // Code style preferences
        if rule.contains("comment") || rule.contains("docstring") || rule.contains("documentation") {
            return "Documentation Style"
        }

        if rule.contains("format") || rule.contains("style") || rule.contains("indent") || rule.contains("spacing") {
            return "Code Formatting"
        }

        if rule.contains("type") || rule.contains("annotation") || rule.contains("hint") {
            return "Type Annotations"
        }

        // Programming preferences
        if rule.contains("function") || rule.contains("method") || rule.contains("class") {
            return "Code Structure"
        }

        if rule.contains("error") || rule.contains("exception") || rule.contains("handle") {
            return "Error Handling"
        }

        if rule.contains("test") || rule.contains("testing") {
            return "Testing"
        }

        // Communication preferences
        if rule.contains("explain") || rule.contains("verbose") || rule.contains("brief") || rule.contains("concise") {
            return "Communication Style"
        }

        // Library/tool preferences
        if rule.contains("use") && (rule.contains("instead") || rule.contains("prefer")) {
            return "Tool Preferences"
        }

        // Default category based on learning type
        switch learning.type {
        case .correction:
            return "Corrections"
        case .positive:
            return "Positive Patterns"
        case .implicit:
            return "Implicit Preferences"
        }
    }

    // MARK: - Discovery

    /// Find CLAUDE.md files in a directory
    func findCLAUDEMDFiles(in directory: URL) -> [URL] {
        var files: [URL] = []

        // Check common locations
        let locations = [
            directory.appendingPathComponent("CLAUDE.md"),
            directory.appendingPathComponent(".claude/CLAUDE.md"),
            directory.appendingPathComponent("docs/CLAUDE.md")
        ]

        for location in locations {
            if FileManager.default.fileExists(atPath: location.path) {
                files.append(location)
            }
        }

        return files
    }

    /// Get the default CLAUDE.md location for a project
    func defaultCLAUDEMDPath(for projectPath: String) -> URL {
        URL(fileURLWithPath: projectPath).appendingPathComponent("CLAUDE.md")
    }

    /// Get the global CLAUDE.md location
    func globalCLAUDEMDPath() -> URL {
        FileManager.default.homeDirectoryForCurrentUser
            .appendingPathComponent(".claude/CLAUDE.md")
    }
}

// MARK: - Profile Builder

/// Builds an AI identity profile from all learnings
final class ProfileBuilder {
    // MARK: - Profile

    struct Profile: Codable {
        var codingStyle: CodingStyle
        var communicationStyle: CommunicationStyle
        var toolPreferences: [ToolPreference]
        var patterns: [String]
        var generatedAt: Date

        struct CodingStyle: Codable {
            var prefersConciseCode: Bool
            var prefersTypeAnnotations: Bool
            var prefersDocstrings: Bool
            var preferredIndentation: String?
            var errorHandlingStyle: String?
        }

        struct CommunicationStyle: Codable {
            var prefersBriefResponses: Bool
            var prefersExplanations: Bool
            var technicality: String // "beginner", "intermediate", "expert"
        }

        struct ToolPreference: Codable {
            var category: String
            var preferred: String
            var avoid: String?
        }
    }

    // MARK: - Build

    /// Build a profile from learnings
    func buildProfile(from learnings: [Learning]) -> Profile {
        var profile = Profile(
            codingStyle: Profile.CodingStyle(
                prefersConciseCode: false,
                prefersTypeAnnotations: false,
                prefersDocstrings: false
            ),
            communicationStyle: Profile.CommunicationStyle(
                prefersBriefResponses: false,
                prefersExplanations: true,
                technicality: "intermediate"
            ),
            toolPreferences: [],
            patterns: [],
            generatedAt: Date()
        )

        for learning in learnings {
            let rule = learning.extractedRule.lowercased()

            // Analyze coding style
            if rule.contains("concise") || rule.contains("simple") || rule.contains("minimal") {
                profile.codingStyle.prefersConciseCode = true
            }

            if rule.contains("type") && rule.contains("annotation") {
                profile.codingStyle.prefersTypeAnnotations = !rule.contains("don't") && !rule.contains("never")
            }

            if rule.contains("docstring") || rule.contains("documentation") {
                profile.codingStyle.prefersDocstrings = !rule.contains("don't") && !rule.contains("never")
            }

            // Analyze communication style
            if rule.contains("brief") || rule.contains("short") {
                profile.communicationStyle.prefersBriefResponses = true
            }

            if rule.contains("explain") {
                profile.communicationStyle.prefersExplanations = !rule.contains("don't")
            }

            // Extract tool preferences
            if let preference = extractToolPreference(from: learning.extractedRule) {
                profile.toolPreferences.append(preference)
            }

            // Add to patterns
            profile.patterns.append(learning.extractedRule)
        }

        return profile
    }

    private func extractToolPreference(from rule: String) -> Profile.ToolPreference? {
        // Pattern: "Use X instead of Y"
        let pattern = #"[Uu]se\s+'?(\w+(?:\s+\w+)?)'?\s+instead\s+of\s+'?(\w+(?:\s+\w+)?)'?"#

        guard let regex = try? NSRegularExpression(pattern: pattern),
              let match = regex.firstMatch(in: rule, range: NSRange(rule.startIndex..., in: rule)),
              let preferredRange = Range(match.range(at: 1), in: rule),
              let avoidRange = Range(match.range(at: 2), in: rule) else {
            return nil
        }

        return Profile.ToolPreference(
            category: "General",
            preferred: String(rule[preferredRange]),
            avoid: String(rule[avoidRange])
        )
    }

    /// Export profile to JSON
    func exportProfile(_ profile: Profile) throws -> Data {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601
        return try encoder.encode(profile)
    }
}
